<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-340cfe4e-66a7-403e-a0a0-d356ec3d6ba8"></attachment><h1><code style="color: rgb(0, 0, 0); background-color: initial;">它在一个网络接口上监听，那你就绑定一个IP或者多个IP。</code></h1><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 示例，多个IP用空格隔开:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># bind&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">192.168</code><code style="color: rgb(0, 0, 0); background-color: initial;">.</code><code style="color: rgb(0, 153, 0); background-color: initial;">1.100</code>&nbsp;<code style="color: rgb(0, 153, 0); background-color: initial;">10.0</code><code style="color: rgb(0, 0, 0); background-color: initial;">.</code><code style="color: rgb(0, 153, 0); background-color: initial;">0.1</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># bind&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">127.0</code><code style="color: rgb(0, 0, 0); background-color: initial;">.</code><code style="color: rgb(0, 153, 0); background-color: initial;">0.1</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 指定 unix socket 的路径。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># unixsocket /tmp/redis.sock</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># unixsocketperm&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">755</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 指定在一个 client 空闲多少秒之后关闭连接（</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">就是不管它）</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">timeout&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># tcp 心跳包。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 如果设置为非零，则在与客户端缺乏通讯的时候使用 SO_KEEPALIVE 发送 tcp acks 给客户端。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 这个之所有有用，主要由两个原因：</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code><code style="color: rgb(0, 0, 0); background-color: initial;">) 防止死的 peers</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">2</code><code style="color: rgb(0, 0, 0); background-color: initial;">) Take the connection alive from the point of view of network</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># equipment in the middle.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># On Linux, the specified value (in seconds) is the period used to send ACKs.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Note that to close the connection the&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">double</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">of the time is needed.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># On other kernels the period depends on the kernel configuration.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># A reasonable value&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">option is&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">60</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">seconds.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 推荐一个合理的值就是</code><code style="color: rgb(0, 153, 0); background-color: initial;">60</code><code style="color: rgb(0, 0, 0); background-color: initial;">秒</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">tcp-keepalive&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 定义日志级别。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 可以是下面的这些值：</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># debug (适用于开发或测试阶段)</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># verbose (many rarely useful info, but not a mess like the debug level)</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># notice (适用于生产环境)</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># warning (仅仅一些重要的消息被记录)</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">loglevel notice</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 指定日志文件的位置</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">logfile&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">""</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 要想把日志记录到系统日志，就把它改成 yes，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 也可以可选择性的更新其他的syslog 参数以达到你的要求</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># syslog-enabled no</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 设置 syslog 的 identity。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># syslog-ident redis</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 设置 syslog 的 facility，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># syslog-facility local0</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 设置数据库的数目。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 默认数据库是 DB&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code><code style="color: rgb(0, 0, 0); background-color: initial;">，你可以在每个连接上使用 select &lt;dbid&gt; 命令选择一个不同的数据库，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 但是 dbid 必须是一个介于&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">到 databasees -&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">之间的值</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">databases&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">16</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">################################ 快照 ################################</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 存 DB 到磁盘：</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 格式：save &lt;间隔时间（秒）&gt; &lt;写入次数&gt;</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 根据给定的时间间隔和写入次数将数据保存到磁盘</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 下面的例子的意思是：</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">900</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">秒内如果至少有&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">个 key 的值变化，则保存</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">300</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">秒内如果至少有&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">个 key 的值变化，则保存</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">60</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">秒内如果至少有&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10000</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">个 key 的值变化，则保存</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># </code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 注意：你可以注释掉所有的 save 行来停用保存功能。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 也可以直接一个空字符串来实现停用：</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># save&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">""</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">save&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">900</code>&nbsp;<code style="color: rgb(0, 153, 0); background-color: initial;">1</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">save&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">300</code>&nbsp;<code style="color: rgb(0, 153, 0); background-color: initial;">10</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">save&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">60</code>&nbsp;<code style="color: rgb(0, 153, 0); background-color: initial;">10000</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 默认情况下，如果 redis 最后一次的后台保存失败，redis 将停止接受写操作，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 否则就会没人注意到灾难的发生。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 如果后台保存进程重新启动工作了，redis 也将自动的允许写操作。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 然而你要是安装了靠谱的监控，你可能不希望 redis 这样做，那你就改成 no 好了。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">stop-writes-on-bgsave-error yes</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 是否在 dump .rdb 数据库的时候使用 LZF 压缩字符串</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 默认都设为 yes</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 如果你希望保存子进程节省点 cpu ，你就设置它为 no ，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 不过这个数据集可能就会比较大</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">rdbcompression yes</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 是否校验rdb文件</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">rdbchecksum yes</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 设置 dump 的文件位置</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">dbfilename dump.rdb</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 工作目录</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 例如上面的 dbfilename 只指定了文件名，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 但是它会写入到这个目录下。这个配置项一定是个目录，而不能是文件名。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">dir ./</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">################################# 主从复制 #################################</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 主从复制。使用 slaveof 来让一个 redis 实例成为另一个reids 实例的副本。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 注意这个只需要在 slave 上配置。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 如果 master 需要密码认证，就在这里设置</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># masterauth &lt;master-password&gt;</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 当一个 slave 与 master 失去联系，或者复制正在进行的时候，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># slave 可能会有两种表现：</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code><code style="color: rgb(0, 0, 0); background-color: initial;">) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 或者数据可能是空的在第一次同步的时候</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">2</code><code style="color: rgb(0, 0, 0); background-color: initial;">) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># slave 都将返回一个&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"SYNC with master in progress"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">的错误，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">slave-serve-stale-data yes</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 你可以配置一个 slave 实体是否接受写入操作。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 通过写入操作来存储一些短暂的数据对于一个 slave 实例来说可能是有用的，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 因为相对从 master 重新同步数而言，据数据写入到 slave 会更容易被删除。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 但是如果客户端因为一个错误的配置写入，也可能会导致一些问题。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 从 redis&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">2.6</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">版起，默认 slaves 都是只读的。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Note: read only slaves are not designed to be exposed to untrusted clients</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># on the internet. It's just a protection layer against misuse of the instance.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Still a read only slave exports by&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">all the administrative commands</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># security of read only slaves using&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">'rename-command'</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">to shadow all the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># administrative / dangerous commands.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 注意：只读的 slaves 没有被设计成在 internet 上暴露给不受信任的客户端。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 它仅仅是一个针对误用实例的一个保护层。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">slave-read-only yes</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Slaves 在一个预定义的时间间隔内发送 ping 命令到 server 。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 你可以改变这个时间间隔。默认为&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">秒。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># repl-ping-slave-period&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The following option sets the replication timeout&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code><code style="color: rgb(0, 0, 0); background-color: initial;">:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 设置主从复制过期时间</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code><code style="color: rgb(0, 0, 0); background-color: initial;">) Bulk transfer I/O during SYNC, from the point of view of slave.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">2</code><code style="color: rgb(0, 0, 0); background-color: initial;">) Master timeout from the point of view of slaves (data, pings).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">3</code><code style="color: rgb(0, 0, 0); background-color: initial;">) Slave timeout from the point of view of masters (REPLCONF ACK pings).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># It is important to make sure that&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">value is greater than the value</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># specified&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">repl-ping-slave-period otherwise a timeout will be detected</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># every time there is low traffic between the master and the slave.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 这个值一定要比 repl-ping-slave-period 大</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># repl-timeout&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">60</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Disable TCP_NODELAY on the slave socket after SYNC?</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># If you select&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"yes"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">Redis will use a smaller number of TCP packets and</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># less bandwidth to send data to slaves. But&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">can add a delay&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the data to appear on the slave side, up to&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">40</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">milliseconds with</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Linux kernels using a&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">configuration.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># If you select&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"no"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the delay&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">data to appear on the slave side will</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># be reduced but more bandwidth will be used&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">replication.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># By&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">we optimize&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">low latency, but in very high traffic conditions</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># or when the master and slaves are many hops away, turning&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">to&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"yes"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">may</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># be a good idea.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">repl-disable-tcp-nodelay no</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 设置主从复制容量大小。这个 backlog 是一个用来在 slaves 被断开连接时</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 存放 slave 数据的 buffer，所以当一个 slave 想要重新连接，通常不希望全部重新同步，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 只是部分同步就够了，仅仅传递 slave 在断开连接时丢失的这部分数据。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The biggest the replication backlog, the longer the time the slave can be</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># disconnected and later be able to perform a partial resynchronization.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 这个值越大，salve 可以断开连接的时间就越长。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The backlog is only allocated once there is at least a slave connected.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># repl-backlog-size 1mb</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># After a master has no longer connected slaves&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">some time, the backlog</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># will be freed. The following option configures the amount of seconds that</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># need to elapse, starting from the time the last slave disconnected,&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the backlog buffer to be freed.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 在某些时候，master 不再连接 slaves，backlog 将被释放。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># A value of&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">means to never release the backlog.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 如果设置为&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">，意味着绝不释放 backlog 。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># repl-backlog-ttl&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">3600</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 当 master 不能正常工作的时候，Redis Sentinel 会从 slaves 中选出一个新的 master，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 这个值越小，就越会被优先选中，但是如果是&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">， 那是意味着这个 slave 不可能被选中。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 默认优先级为&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">100</code><code style="color: rgb(0, 0, 0); background-color: initial;">。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">slave-priority&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">100</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># It is possible&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">a master to stop accepting writes&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">there are less than</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># N slaves connected, having a lag less or equal than M seconds.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The N slaves need to be in&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"online"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">state.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The lag in seconds, that must be &lt;= the specified value, is calculated from</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the last ping received from the slave, that is usually sent every second.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># This option does not GUARANTEES that N replicas will accept the write, but</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># will limit the window of exposure&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">lost writes in&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">case</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">not enough slaves</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># are available, to the specified number of seconds.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># For example to require at least&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">3</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">slaves with a lag &lt;=&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">seconds use:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># min-slaves-to-write&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">3</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># min-slaves-max-lag&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Setting one or the other to&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">disables the feature.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># By&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">min-slaves-to-write is set to&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">(feature disabled) and</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># min-slaves-max-lag is set to&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code><code style="color: rgb(0, 0, 0); background-color: initial;">.</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">################################## 安全 ###################################</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># commands. This might be useful in environments in which you&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">do</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">not trust</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># others with access to the host running redis-server.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># This should stay commented out&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">backward compatibility and because most</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># people&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">do</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">not need auth (e.g. they run their own servers).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Warning: since Redis is pretty fast an outside user can&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">try</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">up to</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 150k passwords per second against a good box. This means that you should</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># use a very strong password otherwise it will be very easy to&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">break</code><code style="color: rgb(0, 0, 0); background-color: initial;">.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 设置认证密码</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># requirepass foobared</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Command renaming.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># It is possible to change the name of dangerous commands in a shared</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># environment. For instance the CONFIG command may be renamed into something</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># hard to guess so that it will still be available&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">internal-use tools</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># but not available&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">general clients.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Example:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># It is also possible to completely kill a command by renaming it into</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># an empty string:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># rename-command CONFIG&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">""</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Please note that changing the name of commands that are logged into the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># AOF file or transmitted to slaves may cause problems.</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">################################### 限制 ####################################</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Set the max number of connected clients at the same time. By&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">limit is set to&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10000</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">clients, however&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the Redis server is not</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># able to configure the process file limit to allow&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the specified limit</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the max number of allowed clients is set to the current file limit</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># minus&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">32</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">(as Redis reserves a few file descriptors&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">internal uses).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 一旦达到最大限制，redis 将关闭所有的新连接</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 并发送一个‘max number of clients reached’的错误。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># maxclients&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10000</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 如果你设置了这个值，当缓存的数据容量达到这个值， redis 将根据你选择的</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># eviction 策略来移除一些 keys。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 如果 redis 不能根据策略移除 keys ，或者是策略被设置为 ‘noeviction’，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># redis 将开始响应错误给命令，如 set，lpush 等等，</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 并继续响应只读的命令，如 get</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># This option is usually useful when using Redis as an LRU cache, or to set</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># a hard memory limit&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">an instance (using the&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">'noeviction'</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">policy).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># WARNING: If you have slaves attached to an instance with maxmemory on,</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the size of the output buffers needed to feed the slaves are subtracted</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># from the used memory count, so that network problems / resyncs will</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># not trigger a loop where keys are evicted, and in turn the output</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># buffer of slaves is full with DELs of keys evicted triggering the deletion</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># of more keys, and so forth until the database is completely emptied.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># In&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">short</code><code style="color: rgb(0, 0, 0); background-color: initial;">...&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">you have slaves attached it is suggested that you set a lower</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># limit&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">maxmemory so that there is some free RAM on the system&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">slave</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># output buffers (but&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">is not needed&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the policy is&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">'noeviction'</code><code style="color: rgb(0, 0, 0); background-color: initial;">).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 最大使用内存</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># maxmemory &lt;bytes&gt;</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 最大内存策略，你有&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">5</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">个选择。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">volatile</code><code style="color: rgb(0, 0, 0); background-color: initial;">-lru -&gt; remove the key with an expire set using an LRU algorithm</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">volatile</code><code style="color: rgb(0, 0, 0); background-color: initial;">-lru -&gt; 使用 LRU 算法移除包含过期设置的 key 。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># allkeys-lru -&gt; remove any key accordingly to the LRU algorithm</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># allkeys-lru -&gt; 根据 LRU 算法移除所有的 key 。</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">volatile</code><code style="color: rgb(0, 0, 0); background-color: initial;">-random -&gt; remove a random key with an expire set</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># allkeys-random -&gt; remove a random key, any key</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">volatile</code><code style="color: rgb(0, 0, 0); background-color: initial;">-ttl -&gt; remove the key with the nearest expire time (minor TTL)</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># noeviction -&gt; don't expire at all, just&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">return</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">an error on write operations</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># noeviction -&gt; 不让任何 key 过期，只是给写入操作返回一个错误</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Note: with any of the above policies, Redis will&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">return</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">an error on write</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># operations, when there are not suitable keys&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">eviction.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># At the date of writing&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">commands are: set setnx setex append</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># getset mset msetnx exec sort</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">is:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># maxmemory-policy noeviction</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># LRU and minimal TTL algorithms are not precise algorithms but approximated</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># algorithms (in order to save memory), so you can tune it&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">speed or</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># accuracy. For&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">Redis will check five keys and pick the one that was</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># used less recently, you can change the sample size using the following</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># configuration directive.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">of&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">5</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">produces good enough results.&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">Approximates very closely</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">true</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">LRU but costs a bit more CPU.&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">3</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">is very fast but not very accurate.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># maxmemory-samples&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">5</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">############################## APPEND ONLY MODE ###############################</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># By&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">Redis asynchronously dumps the dataset on disk. This mode is</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># good enough in many applications, but an issue with the Redis process or</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># a power outage may result into a few minutes of writes lost (depending on</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the configured save points).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The Append Only File is an alternative persistence mode that provides</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># much better durability. For instance using the&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">data fsync policy</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># (see later in the config file) Redis can lose just one second of writes in a</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># dramatic event like a server power outage, or a single write&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">something</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># wrong with the Redis process itself happens, but the operating system is</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># still running correctly.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># AOF and RDB persistence can be enabled at the same time without problems.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># If the AOF is enabled on startup Redis will load the AOF, that is the file</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># with the better durability guarantees.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Please check http:</code><code style="color: rgb(0, 130, 0); background-color: initial;">//redis.io/topics/persistence for more information.</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">appendonly no</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The name of the append only file (</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code><code style="color: rgb(0, 0, 0); background-color: initial;">:&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"appendonly.aof"</code><code style="color: rgb(0, 0, 0); background-color: initial;">)</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">appendfilename&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"appendonly.aof"</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The fsync() call tells the Operating System to actually write data on disk</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># instead to wait&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">more data in the output buffer. Some OS will really flush</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># data on disk, some other OS will just&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">try</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">to&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">do</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">it ASAP.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Redis supports three different modes:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># no: don't fsync, just let the OS flush the data when it wants. Faster.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># always: fsync after every write to the append only log . Slow, Safest.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># everysec: fsync only one time every second. Compromise.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">is&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"everysec"</code><code style="color: rgb(0, 0, 0); background-color: initial;">, as that's usually the right compromise between</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># speed and data safety. It's up to you to understand&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">you can relax&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">to</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"no"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">that will let the operating system flush the output buffer when</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># it wants,&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">better performances (but&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">you can live with the idea of</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># some data loss consider the&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">persistence mode that's snapshotting),</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># or on the contrary, use&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"always"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">that's very slow but a bit safer than</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># everysec.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># More details please check the following article:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># http:</code><code style="color: rgb(0, 130, 0); background-color: initial;">//antirez.com/post/redis-persistence-demystified.html</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># If unsure, use&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"everysec"</code><code style="color: rgb(0, 0, 0); background-color: initial;">.</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># appendfsync always</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">appendfsync everysec</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># appendfsync no</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># When the AOF fsync policy is set to always or everysec, and a background</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># saving process (a background save or AOF log background rewriting) is</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># performing a lot of I/O against the disk, in some Linux configurations</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Redis may block too&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">long</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">on the fsync() call. Note that there is no fix&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">currently, as even performing fsync in a different thread will block</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># our synchronous write(</code><code style="color: rgb(0, 153, 0); background-color: initial;">2</code><code style="color: rgb(0, 0, 0); background-color: initial;">) call.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># In order to mitigate&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">problem it's possible to use the following option</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># that will prevent fsync() from being called in the main process&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">while</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">a</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># BGSAVE or BGREWRITEAOF is in progress.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># This means that&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">while</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">another child is saving, the durability of Redis is</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the same as&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"appendfsync none"</code><code style="color: rgb(0, 0, 0); background-color: initial;">. In practical terms,&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">means that it is</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># possible to lose up to&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">30</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">seconds of log in the worst scenario (with the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">Linux settings).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># If you have latency problems turn&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">to&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"yes"</code><code style="color: rgb(0, 0, 0); background-color: initial;">. Otherwise leave it as</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"no"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">that is the safest pick from the point of view of durability.</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">no-appendfsync-on-rewrite no</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Automatic rewrite of the append only file.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Redis is able to automatically rewrite the log file implicitly calling</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># This is how it works: Redis remembers the size of the AOF file after the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># latest rewrite (</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">no rewrite has happened since the restart, the size of</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the AOF at startup is used).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># This base size is compared to the current size. If the current size is</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># bigger than the specified percentage, the rewrite is triggered. Also</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># you need to specify a minimal size&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the AOF file to be rewritten,&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># is useful to avoid rewriting the AOF file even&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the percentage increase</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># is reached but it is still pretty small.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Specify a percentage of zero in order to disable the automatic AOF</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># rewrite feature.</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">auto-aof-rewrite-percentage&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">100</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">auto-aof-rewrite-min-size 64mb</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">################################ LUA SCRIPTING ###############################</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Max execution time of a Lua script in milliseconds.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># If the maximum execution time is reached Redis will log that a script is</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># still in execution after the maximum allowed time and will start to</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># reply to queries with an error.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># When a&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">long</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">running script exceed the maximum execution time only the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># used to stop a script that did not yet called write commands. The second</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># is the only way to shut down the server in the&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">case</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">a write commands was</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># already issue by the script but the user don't want to wait&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the natural</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># termination of the script.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Set it to&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">or a negative value&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">unlimited execution without warnings.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">lua-time-limit&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">5000</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">################################ REDIS 集群 ###############################</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># 启用或停用集群</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># cluster-enabled yes</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Every cluster node has a cluster configuration file. This file is not</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># intended to be edited by hand. It is created and updated by Redis nodes.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Every Redis Cluster node requires a different cluster configuration file.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Make sure that instances running in the same system does not have</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># overlapping cluster configuration file names.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># cluster-config-file nodes-</code><code style="color: rgb(0, 153, 0); background-color: initial;">6379</code><code style="color: rgb(0, 0, 0); background-color: initial;">.conf</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Cluster node timeout is the amount of milliseconds a node must be unreachable</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">it to be considered in failure state.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Most other internal time limits are multiple of the node timeout.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># cluster-node-timeout&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">15000</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># A slave of a failing master will avoid to start a failover&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">its data</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># looks too old.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># There is no simple way&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">a slave to actually have a exact measure of</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># its&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"data age"</code><code style="color: rgb(0, 0, 0); background-color: initial;">, so the following two checks are performed:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code><code style="color: rgb(0, 0, 0); background-color: initial;">) If there are multiple slaves able to failover, they exchange messages</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># in order to&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">try</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">to give an advantage to the slave with the best</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># replication offset (more data from the master processed).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Slaves will&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">try</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">to get their rank by offset, and apply to the start</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># of the failover a delay proportional to their rank.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">2</code><code style="color: rgb(0, 0, 0); background-color: initial;">) Every single slave computes the time of the last interaction with</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># its master. This can be the last ping or command received (</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the master</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># is still in the&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"connected"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">state), or the time that elapsed since the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># disconnection with the master (</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the replication link is currently down).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># If the last interaction is too old, the slave will not&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">try</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">to failover</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># at all.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The point&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"2"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">can be tuned by user. Specifically a slave will not perform</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the failover&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code><code style="color: rgb(0, 0, 0); background-color: initial;">, since the last interaction with the master, the time</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># elapsed is greater than:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># (node-timeout * slave-validity-factor) + repl-ping-slave-period</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># So&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">example&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">node-timeout is&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">30</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">seconds, and the slave-validity-factor</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># is&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code><code style="color: rgb(0, 0, 0); background-color: initial;">, and assuming a&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">repl-ping-slave-period of&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">seconds, the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># slave will not&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">try</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">to failover&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">it was not able to talk with the master</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">longer than&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">310</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">seconds.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># A large slave-validity-factor may allow slaves with too old data to failover</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># a master,&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">while</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">a too small value may prevent the cluster from being able to</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># elect a slave at all.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># For maximum availability, it is possible to set the slave-validity-factor</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># to a value of&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code><code style="color: rgb(0, 0, 0); background-color: initial;">, which means, that slaves will always&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">try</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">to failover the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># master regardless of the last time they interacted with the master.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># (However they'll always&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">try</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">to apply a delay proportional to their</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># offset rank).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Zero is the only value able to guarantee that when all the partitions heal</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the cluster will always be able to&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">continue</code><code style="color: rgb(0, 0, 0); background-color: initial;">.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># cluster-slave-validity-factor&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Cluster slaves are able to migrate to orphaned masters, that are masters</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># that are left without working slaves. This improves the cluster ability</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># to resist to failures as otherwise an orphaned master can't be failed over</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># in&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">case</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">of failure&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">it has no working slaves.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Slaves migrate to orphaned masters only&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">there are still at least a</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># given number of other working slaves&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">their old master. This number</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># is the&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"migration barrier"</code><code style="color: rgb(0, 0, 0); background-color: initial;">. A migration barrier of&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">means that a slave</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># will migrate only&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">there is at least&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">other working slave&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">its master</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># and so forth. It usually reflects the number of slaves you want&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">every</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># master in your cluster.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Default is&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">(slaves migrate only&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">their masters remain with at least</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># one slave). To disable migration just set it to a very large value.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># A value of&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">can be set but is useful only&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">debugging and dangerous</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># in production.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># cluster-migration-barrier&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># In order to setup your cluster make sure to read the documentation</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># available at http:</code><code style="color: rgb(0, 130, 0); background-color: initial;">//redis.io web site.</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">################################## SLOW LOG ###################################</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The Redis Slow Log is a system to log queries that exceeded a specified</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># execution time. The execution time does not include the I/O operations</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># like talking with the client, sending the reply and so forth,</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># but just the time needed to actually execute the command (</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">is the only</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># stage of command execution where the thread is blocked and can not serve</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># other requests in the meantime).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># You can configure the slow log with two parameters: one tells Redis</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># what is the execution time, in microseconds, to exceed in order&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># command to get logged, and the other parameter is the length of the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># slow log. When a&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">new</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">command is logged the oldest one is removed from the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># queue of logged commands.</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The following time is expressed in microseconds, so&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1000000</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">is equivalent</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># to one second. Note that a negative number disables the slow log,&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">while</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># a value of zero forces the logging of every command.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">slowlog-log-slower-than&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10000</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># There is no limit to&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">length. Just be aware that it will consume memory.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># You can reclaim memory used by the slow log with SLOWLOG RESET.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">slowlog-max-len&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">128</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">############################# Event notification ##############################</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Redis can notify Pub/Sub clients about events happening in the key space.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># This feature is documented at http:</code><code style="color: rgb(0, 130, 0); background-color: initial;">//redis.io/topics/keyspace-events</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># For instance&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">keyspace events notification is enabled, and a client</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># performs a DEL operation on key&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"foo"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">stored in the Database&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code><code style="color: rgb(0, 0, 0); background-color: initial;">, two</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># messages will be published via Pub/Sub:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># PUBLISH __keyspace</code><code style="color: rgb(128, 128, 128); background-color: initial;">@0__</code><code style="color: rgb(0, 0, 0); background-color: initial;">:foo del</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># PUBLISH __keyevent</code><code style="color: rgb(128, 128, 128); background-color: initial;">@0__</code><code style="color: rgb(0, 0, 0); background-color: initial;">:del foo</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># It is possible to select the events that Redis will notify among a set</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># of classes. Every&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">class</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">is identified by a single character:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># K Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># E Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># g Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># $ String commands</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># l List commands</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># s Set commands</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># h Hash commands</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># z Sorted set commands</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># x Expired events (events generated every time a key expires)</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># e Evicted events (events generated when a key is evicted&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">maxmemory)</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># A Alias&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">g$lshzxe, so that the&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"AKE"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">string means all the events.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"notify-keyspace-events"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">takes as argument a string that is composed</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># by zero or multiple characters. The empty string means that notifications</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># are disabled at all.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Example: to enable list and generic events, from the point of view of the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># event name, use:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># notify-keyspace-events Elg</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Example&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">2</code><code style="color: rgb(0, 0, 0); background-color: initial;">: to get the stream of the expired keys subscribing to channel</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># name __keyevent</code><code style="color: rgb(128, 128, 128); background-color: initial;">@0__</code><code style="color: rgb(0, 0, 0); background-color: initial;">:expired use:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># notify-keyspace-events Ex</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># By&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">all notifications are disabled because most users don't need</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">feature and the feature has some overhead. Note that&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">you don't</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># specify at least one of K or E, no events will be delivered.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">notify-keyspace-events&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">""</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;">############################### ADVANCED CONFIG ###############################</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Hashes are encoded using a memory efficient data structure when they have a</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># small number of entries, and the biggest entry does not exceed a given</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># threshold. These thresholds can be configured using the following directives.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">hash-max-ziplist-entries&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">512</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">hash-max-ziplist-value&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">64</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Similarly to hashes, small lists are also encoded in a special way in order</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># to save a lot of space. The special representation is only used when</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># you are under the following limits:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">list-max-ziplist-entries&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">512</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">list-max-ziplist-value&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">64</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Sets have a special encoding in just one&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">case</code><code style="color: rgb(0, 0, 0); background-color: initial;">: when a set is composed</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># of just strings that happens to be integers in radix&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">in the range</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># of&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">64</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">bit signed integers.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The following configuration setting sets the limit in the size of the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># set in order to use&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">special memory saving encoding.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">set-max-intset-entries&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">512</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Similarly to hashes and lists, sorted sets are also specially encoded in</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># order to save a lot of space. This encoding is only used when the length and</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># elements of a sorted set are below the following limits:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">zset-max-ziplist-entries&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">128</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">zset-max-ziplist-value&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">64</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># HyperLogLog sparse representation bytes limit. The limit includes the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">16</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">bytes header. When an HyperLogLog using the sparse representation crosses</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">limit, it is converted into the dense representation.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># A value greater than&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">16000</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">is totally useless, since at that point the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># dense representation is more memory efficient.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The suggested value is ~&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">3000</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">in order to have the benefits of</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the space efficient encoding without slowing down too much PFADD,</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># which is O(N) with the sparse encoding. The value can be raised to</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># ~&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10000</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">when CPU is not a concern, but space is, and the data set is</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># composed of many HyperLogLogs with cardinality in the&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">-&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">15000</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">range.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">hll-sparse-max-bytes&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">3000</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Active rehashing uses&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">millisecond every&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">100</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">milliseconds of CPU time in</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># order to help rehashing the main Redis hash table (the one mapping top-level</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># keys to values). The hash table implementation Redis uses (see dict.c)</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># performs a lazy rehashing: the more operation you run into a hash table</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># that is rehashing, the more rehashing&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"steps"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">are performed, so&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># server is idle the rehashing is never complete and some more memory is used</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># by the hash table.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">is to use&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">millisecond&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">times every second in order to</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># active rehashing the main dictionaries, freeing memory when possible.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># If unsure:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># use&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"activerehashing no"</code>&nbsp;<code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">you have hard latency requirements and it is</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># not a good thing in your environment that Redis can reply form time to time</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># to queries with&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">2</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">milliseconds delay.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># use&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"activerehashing yes"</code>&nbsp;<code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">you don't have such hard requirements but</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># want to free memory asap when possible.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">activerehashing yes</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The client output buffer limits can be used to force disconnection of clients</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># that are not reading data from the server fast enough&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">some reason (a</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># common reason is that a Pub/Sub client can't consume messages as fast as the</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># publisher can produce them).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The limit can be set differently&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the three different classes of clients:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># normal -&gt; normal clients</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># slave -&gt; slave clients and MONITOR clients</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The syntax of every client-output-buffer-limit directive is the following:</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># client-output-buffer-limit &lt;</code><code style="color: rgb(0, 0, 255); background-color: initial;">class</code><code style="color: rgb(0, 0, 0); background-color: initial;">&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># A client is immediately disconnected once the hard limit is reached, or&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the soft limit is reached and remains reached&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the specified number of</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># seconds (continuously).</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># So&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">instance&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the hard limit is&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">32</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">megabytes and the soft limit is</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">16</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">megabytes /&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">seconds, the client will get disconnected immediately</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the size of the output buffers reach&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">32</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">megabytes, but will also get</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># disconnected&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the client reaches&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">16</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">megabytes and continuously overcomes</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the limit&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 153, 0); background-color: initial;">10</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">seconds.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># By&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">normal clients are not limited because they don't receive data</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># without asking (in a push way), but just after a request, so only</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># asynchronous clients may create a scenario where data is requested faster</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># than it can read.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Instead there is a&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">limit&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">pubsub and slave clients, since</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># subscribers and slaves receive data in a push fashion.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Both the hard or the soft limit can be disabled by setting them to zero.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">client-output-buffer-limit normal&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 153, 0); background-color: initial;">0</code>&nbsp;<code style="color: rgb(0, 153, 0); background-color: initial;">0</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">client-output-buffer-limit slave 256mb 64mb&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">60</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">client-output-buffer-limit pubsub 32mb 8mb&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">60</code>&nbsp;&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;"># Redis订阅客户端订阅buffer超过32M或持续</code><code style="color: rgb(0, 153, 0); background-color: initial;">60</code><code style="color: rgb(0, 0, 0); background-color: initial;">秒超过8M,订阅立即被关闭！</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Redis calls an internal function to perform many background tasks, like</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># closing connections of clients in timeout, purging expired keys that are</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># never requested, and so forth.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Not all tasks are performed with the same frequency, but Redis checks&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">for</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># tasks to perform accordingly to the specified&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">"hz"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">value.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># By&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 255); background-color: initial;">"hz"</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">is set to&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code><code style="color: rgb(0, 0, 0); background-color: initial;">. Raising the value will use more CPU when</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># Redis is idle, but at the same time will make Redis more responsive when</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># there are many keys expiring at the same time, and timeouts may be</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># handled with more precision.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># The range is between&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">1</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">and&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">500</code><code style="color: rgb(0, 0, 0); background-color: initial;">, however a value over&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">100</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">is usually not</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># a good idea. Most users should use the&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">default</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">of&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">and raise&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">this</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">up to</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">#&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">100</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">only in environments where very low latency is required.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">hz&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">10</code></p><p>&nbsp;</p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># When a child rewrites the AOF file,&nbsp;</code><code style="color: rgb(0, 0, 255); background-color: initial;">if</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">the following option is enabled</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># the file will be fsync-ed every&nbsp;</code><code style="color: rgb(0, 153, 0); background-color: initial;">32</code>&nbsp;<code style="color: rgb(0, 0, 0); background-color: initial;">MB of data generated. This is useful</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># in order to commit the file to the disk more incrementally and avoid</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;"># big latency spikes.</code></p><p><code style="color: rgb(0, 0, 0); background-color: initial;">aof-rewrite-incremental-fsync yes</code></p><p><br></p>